import json
import os
import re
import shutil
from typing import Dict, List, Optional

import numpy as np
from openai import OpenAI
from agent.base_agent import BaseAgent, Controller
from agent.llm_hcg.library_controller import ControllerLibrary
from agent.llm_hcg.demo_bank import DemoBank, TransitionData
from core.task import TaskRepresentation
from core.utils import get_error_info
from env.base_meta_env import BaseMetaEnv, Observation, ActionType, InfoDict
from abc import ABC, abstractmethod
import enum
import random
from typing import Any, Dict, Tuple, Union
from hydra.utils import instantiate
from llm import llm_name_to_LLMClass


class LLMBasedHierarchicalControllerGenerator(BaseAgent):

    def __init__(self, config: Dict):
        super().__init__(config)
        # Initialize LLM
        name_llm = config["llm"]["name"]
        config_llm = config["llm"]["config"]
        self.llm = llm_name_to_LLMClass[name_llm](config_llm)
        self.text_base_controller = open("agent/base_controller.py").read()
        self.text_example_answer_inference = open(
            "agent/llm_hcg/example_answer_inference.txt"
        ).read()
        self.text_example_answer_update = open(
            "agent/llm_hcg/example_answer_update.txt"
        ).read()
        self.text_example_pc = open("agent/llm_hcg/initial_PCs/move_forward.py").read()
        self.text_example_sc = open("agent/llm_hcg/initial_SCs/go_north.py").read().replace("..utils_PCs", "controller_library") # Replace the import of the PC by the import of the library
        # Extract the configuration parameters
        self.model = config["model"]
        self.num_attempts_answer2controller = config.get(
            "num_attempts_answer2controller", 5
        )
        self.n_inference = self.config.get("n_inference", 5)
        self.method_inference_sampling = self.config.get(
            "method_inference_sampling", "uniform"
        )
        self.n_training = self.config.get("n_training", 20)
        self.method_training_sampling = self.config.get(
            "method_training_sampling", "uniform"
        )
        self.n_max_training_new_primitives = self.config.get(
            "n_max_training_new_primitives", 5
        )
        self.n_max_training_refactorings = self.config.get(
            "n_max_training_refactorings", 3
        )
        # Initialize agent's variables
        self.t = 0  # Time step
        # Define the base namespace that can be used by the assistant
        self.namespace = {}
        exec(open("agent/llm_hcg/base_namespace.py").read(), self.namespace)
        self.sc_code_last: Optional[str] = (
            None  # The code of the controller generated by the assistant
        )
        # Initialize knowledge base
        self.library_controller = ControllerLibrary(
            config_agent=config,
        )
        self.demo_bank = DemoBank(
            config_agent=config,
        )
        # Initialize logging
        config_logs = self.config["config_logs"]
        self.log_dir = config_logs["log_dir"]
        self.list_run_names = []
        if config_logs["do_log_on_new"]:
            self.list_run_names.append(self.config["run_name"])
        if config_logs["do_log_on_last"]:
            self.list_run_names.append("_last")
        # Log the config
        self.log_texts(
            {"config.yaml": json.dumps(self.config, indent=4)}, in_task_folder=False
        )

    def give_textual_description(self, description: str):
        self.description_env = description

    def get_controller(self, task_description: TaskRepresentation) -> Controller:

        # Extract demo bank examples to be given as in-context examples
        transitions_datas_sampled = self.demo_bank.sample_transitions(
            n_transitions=self.n_inference,
            method=self.method_inference_sampling,
            task_description=task_description,
        )
        examples_demobank = "\n\n".join(
            repr(transition_data) for transition_data in transitions_datas_sampled
        )

        # Create the prompt for the assistant
        prompt = (
            # Purpose prompt
            "You will be asked to generate the code for a Controller and instanciate this controller for a given task in a RL-like environment. "
            "\n\n"
            # Environment prompt
            "[General description of the environment]\n"
            f"{self.description_env}\n"
            "\n\n"
            # Controller structure prompt
            "[Controller interface]\n"
            "A controller obeys the following interface:\n"
            "Note : you MUST import the objects Controller, Observation, ActionType from the 'agent.base_agent' module.\n"
            "Also, you shall import any other python module you need (numpy as np, math, etc.).\n"
            "```python\n"
            f"{self.text_base_controller}```"
            "\n\n"
            # Knowledge base prompt
            "[Controller library]\n"
            "You have here controllers that are already defined in the 'controller_library' module. "
            "You are not forced to use them (you can define your own controller class and then instanciate it) but you can use them. \n"
            "If you wish to use them, you can import them in your code using the following syntax:\n"
            "```python\n"
            "from controller_library import Controller1, Controller2\n"
            "```\n"
            "If you use them, take care of the signatures of the methods of the controllers you use. \n"
            "\n"
            f"{self.library_controller}"
            "\n\n"
            # Demo bank prompt
            "[Examples]\n"
            "Here are some examples of code used to solve similar tasks in the past. "
            "For each example, you are given the task description, the code used to solve it and the feedback given to the agent after the execution of the controller (performance of the agent, error detected, etc.). "
            "You can see these good/bad examples (depending on feedback) as a source of inspiration to solve the task. "
            "\n\n"
            f"{examples_demobank}"
            "\n\n"
            # Advice prompt
            "[Advices]\n"
            "You can write a new controller class and/or use the controllers that are already implemented in the knowledge base. "
            "If you define a controller from scratch, you can't define functions outside the controller class, you need to define them inside the class as methods. "
            "Your code should create a 'controller' variable that will be extracted for performing in the environment\n"
            # "\n" # (commented for now)
            # "You should try as much as possible to produce controllers that are short in terms of tokens of code. "
            # "This can be done in particular by re-using the functions and controllers that are already implemented in the knowledge base and won't cost a lot of tokens. "
            "\n"
            "Please reason step-by-step and think about the best way to solve the task before answering. "
            "\n\n"
            # Example of answer prompt (in-context learning)
            "[Example of answer]\n"
            "Your answer should be returned following that example:\n"
            f"{self.text_example_answer_inference}"
            "\n\n"
            # Task prompt
            "[Task to solve]\n"
            f"You will have to implement a controller (under the variable 'controller') to solve the following task : \n{task_description}."
        )

        # Log the prompt and the task description
        self.log_texts(
            {
                "prompt.txt": prompt,
                "demo_bank_examples.txt": "\n\n".join(
                    repr(transition_data)
                    for transition_data in transitions_datas_sampled
                ),
                "task_description.txt": repr(task_description),
            },
        )

        # Breakpoint-pause at each task if the debug mode is activated
        if self.config["config_debug"]["breakpoint_on_new_task"]:
            print(f"Task {self.t} : {task_description}. Press 'c' to continue.")
            breakpoint()

        # Iterate until the controller is generated. If error, log it in the message and ask the assistant to try again.
        is_controller_instance_generated = False
        self.llm.reset()
        self.llm.add_prompt(prompt)
        for no_attempt in range(self.num_attempts_answer2controller):
            # Ask the assistant
            answer = self.llm.generate()
            # Extract the code block from the answer
            code = self.extract_code(answer)
            if code is None:
                # Retry if the code could not be extracted
                print(
                    f"[WARNING] : Could not extract the code from the answer. Asking the assistant to try again. (Attempt {no_attempt+1}/{self.num_attempts_answer2controller})"
                )
                self.llm.add_answer(answer)
                self.llm.add_prompt(
                    "I'm sorry, extracting the code from your answer failed. Please try again and make sure the code obeys the following format:\n```python\n<your code here>\n```"
                )
                self.log_texts(
                    {f"assistant_answer_failed_{no_attempt}_extract_reason.txt": answer}
                )
                if self.config["config_debug"][
                    "breakpoint_on_failed_controller_extraction"
                ]:
                    print("controller code extraction failed. Press 'c' to continue.")
                    breakpoint()
                continue
            # Extract the controller
            try:
                controller_instance = self.get_controller_instance(code)
            except Exception as e:
                full_error_info = get_error_info(e)
                print(
                    f"[WARNING] : Could not execute the code from the answer. Asking the assistant to try again (Attempt {no_attempt+1}/{self.num_attempts_answer2controller}). Full error info : {full_error_info}"
                )
                self.llm.add_answer(answer)
                self.llm.add_prompt(
                    f"I'm sorry, an error occured while executing your code. Please try again and make sure the code is correct. Full error info : {full_error_info}"
                )
                self.log_texts(
                    {
                        f"assistant_answer_failed_{no_attempt}_exec_reason.txt": answer,
                        f"error_info_exec_{no_attempt}.txt": full_error_info,
                    }
                )
                if self.config["config_debug"][
                    "breakpoint_on_failed_controller_extraction"
                ]:
                    print("controller code execution failed. Press 'c' to continue.")
                    breakpoint()
                continue
            # Save the code for update step and return the controller instance
            self.sc_code_last = code
            is_controller_instance_generated = True
            break

        if is_controller_instance_generated:
            self.log_texts(
                {
                    "assistant_answer.txt": answer,
                    "controller.py": code,
                }
            )
            return controller_instance

        else:
            raise ValueError(
                f"Could not generate a controller after {self.num_attempts_answer2controller} attempts. Stopping the process."
            )

    # ================ Update step ================

    def update(
        self,
        task_repr: TaskRepresentation,
        controller: Controller,
        feedback: Dict[str, Union[float, str]],
    ):
        # Add the transition to the demo bank
        self.demo_bank.add_transition(
            transition=TransitionData(
                task_repr=task_repr, code=self.sc_code_last, feedback=feedback
            )
        )
        # Log the feedback and the task description
        self.log_texts(
            {
                "feedback.txt": json.dumps(feedback, indent=4),
            }
        )
        # Update the knowledge base
        if self.t % 10 == 0:
            transitions = self.demo_bank.sample_transitions(
                n_transitions=self.n_training,
                method=self.method_training_sampling,
            )
            examples_demobank = []
            for idx, (task_repr, code, feedback) in enumerate(transitions):
                examples_demobank.append(
                    (
                        f"Task no {idx+1} :\n"
                        f"{task_repr}\n\n"
                        f"Super controller code :\n{code}\n\n"
                        f"Performance : {feedback['success']}"
                    )
                )
            examples_demobank = "\n\n".join(examples_demobank)

            examples_demobank = "\n\n".join(
                repr(transition) for transition in transitions
            )
            # Create the prompt for the assistant
            prompt_update = (
                # Purpose prompt
                "We are in the context of solving a task-based environment. The tasks consist of interacting with the environment for several steps in order to achieve a specified goal. "
                "The objects that operates in the environment are called controllers and are sub-classes of the class Controller. "
                "We maintain a library of (primitive) controllers that are relatively low-level controllers that can be composed by the actually deployed (super) controllers. "
                "We also maintain a demo bank of transitions (task representation, controller code, feedback) that happened during the agent's training. "
                "You are an agent that is asked to 1) improve the library of controllers and 2) refactor if needed the super controller codes that are used in the demo bank. "
                "\n\n"
                # Environment prompt
                "[General description of the environment]\n"
                f"{self.description_env}\n"
                "\n\n"
                # Controller structure prompt
                "[Controller interface]\n"
                "A controller obeys the following interface:\n"
                "Note : you MUST import the objects Controller, Observation, and ActionType from the 'agent.base_agent' module.\n"
                "Also, you shall import any other python module you need (numpy as np, math, etc.).\n"
                "```python\n"
                f"{self.text_base_controller}```"
                "\n\n"
                # Knowledge base prompt
                "[Controller library (to improve)]\n"
                "You have here the library of controllers that are already defined in the 'controller_library' module. "
                "You cannot use them in the definition of other primitive controllers of the library, but you can use them in the definition of the super controllers when you refactor the demo bank. "
                "If you wish to use them, you can import them in your super controller code using the following syntax:\n"
                "```python\n"
                "from controller_library import Controller1, Controller2\n"
                "```\n"
                "If you use them, take care of the signatures of the methods of the controllers you use. \n"
                "\n"
                f"{self.library_controller}"
                "\n\n"
                "You are asked to improve the library of controllers by making it more modular and creating usefull primitive controllers that can be used in the super controllers. "
                f"You can add up to {self.n_max_training_new_primitives} new controllers to the library. "
                "You CAN'T add a controller that is already present in the library. "
                "For adding a new primitive controller to the library, include 'New primitive controller' followed by "
                "the definition of the controller in your answer. Example:\n"
                "New primitive controller:\n"
                "```python\n"
                f"{self.text_example_pc}```"
                "\n\n"
                # Demo bank prompt
                "[Demo Bank (to refactor)]\n"
                "Here are some transitions (task description, controller code, performance) that happened during the agent's training. "
                "Based on these experiences and the controller library, you are asked to refactor the controller code to improve the agent's performance. "
                "The performance is a scalar between 0 and 1. If the scalar is near 1, you can hardly improve the controller but you may make it more modular by using the library. "
                "\n\n"
                f"{examples_demobank}"
                "\n\n"
                "You can refactor the controller code by using the controllers from the library, or by defining new controllers that possibly compose the primitive controllers from the library. "
                f"You can refactor between 1 to {self.n_max_training_refactorings} controllers from the demo bank. "
                "For refactoring a controller from the demo bank, include 'Refactored controller for task <idx task>' followed by "
                "the definition of the controller in your answer. Example:\n"
                "Refactored controller for task 3:\n"
                "```python\n"
                f"{self.text_example_sc}```"
                "\n\n"
                # Advice prompt
                # "[Advices]\n"
                # "You can write a new controller class and/or use the controllers that are already implemented in the knowledge base. "
                # "If you define a controller from scratch, you can't define functions outside the controller class, you need to define them inside the class as methods. "
                # "Your code should create a 'controller' variable that will be extracted for performing in the environment\n"
                # "\n" # (commented for now)
                # "You should try as much as possible to produce controllers that are short in terms of tokens of code. "
                # "This can be done in particular by re-using the functions and controllers that are already implemented in the knowledge base and won't cost a lot of tokens. "
                "\n"
                "Please reason step-by-step and think about the best way to solve the task before answering. "
                "\n\n"
                # Example of answer prompt (in-context learning)
                "[Example of answer]\n"
                "Your answer should be returned following that example:\n"
                f"{self.text_example_answer_update}"
            )
            self.log_texts(
                {
                    "prompt_update.txt": prompt_update,
                    "controller_library.py": self.library_controller.__repr__(),
                    "demo_bank.txt": self.demo_bank.__repr__(),
                },
                is_update_step=True,
            )
            if self.config["config_debug"]["breakpoint_on_update"]:
                print("Update step. Press 'c' to continue.")
                breakpoint()

        # Increment the time step
        self.t += 1

    # ================ Helper functions ================

    def extract_code(self, answer: str) -> str:
        """Extracts the controller definition and instantiation code from an LLM response.
        The answer should contain one python code block with the controller code and instanciate a Controller variable named 'controller'.

        Answer is expected to be structured as follows:
            Reasoning:
            <reasoning>

            Controller:
            ```python
            <code>
            ```

        Args:
            answer (str): the answer from the LLM.

        Returns:
            str: the controller code.
        """
        sc_match = re.search(r"```python\n(.*?)\n```", answer, re.DOTALL)
        sc_code = sc_match.group(1).strip() if sc_match else None
        return sc_code

    def get_controller_instance(self, code: str) -> Controller:
        """Execute the code given by the LLM and return the controller instance.

        Code is expected to be structured as follows:
        ```python
        from controller_library import Controller1, Controller2
        import numpy as np

        class MyController(Controller1):
            ... # code for the controller

        controller = MyController()
        ```

        Because some imports may be fictional imports from the 'controller_library' module, we first extract those and execute them.

        Args:
            code (str): a string containing the code.
            The code should be structured as :
            - import statements from the (fictional) controller_library module (optional)
            - import statements from other standard modules (optional)
            - class definition (optional)
            - controller instantiation (mandatory)

        Returns:
            Controller: the controller instance.
        """
        # Extract imports from 'controller_library'
        lines = code.split("\n")
        lines_without_controller_imports: List[str] = []
        controller_classes_names: List[str] = []

        for line in lines:
            match = re.match(r"^\s*from\s+controller_library\s+import\s+(.+)$", line)
            if match:
                controller_classes_names.extend(
                    [cls.strip() for cls in match.group(1).split(",")]
                )
            else:
                lines_without_controller_imports.append(line)

        # Create a new execution context
        exec_globals = {}

        # Execute controller imports first
        for controller_name in controller_classes_names:
            assert (
                controller_name in self.library_controller.controllers
            ), f"Controller {controller_name} not found in the library."
            controller_code = self.library_controller.controllers[controller_name].code
            try:
                exec(controller_code, exec_globals)
            except Exception as e:
                raise ValueError(
                    f"An error occured while executing the code of the controller {controller_name} from the library. Maybe don't import this controller anymore. Full error info : {get_error_info(e)}"
                )
        # Execute the remaining code
        try:
            exec("\n".join(lines_without_controller_imports), exec_globals)
        except Exception as e:
            raise ValueError(
                f"An error occured while executing the code for instanciating a controller. Full error info : {get_error_info(e)}"
            )

        # Retrieve the controller instance specifically from 'controller' variable
        if "controller" in exec_globals and isinstance(
            exec_globals["controller"], Controller
        ):
            return exec_globals["controller"]
        else:
            raise ValueError(
                "No object named 'controller' of the class Controller found in the provided code."
            )

    def log_texts(
        self,
        dict_name_to_text: Dict[str, str],
        in_task_folder: bool = True,
        is_update_step: bool = False,
    ):
        """Log texts in a directory. For each (key, value) in the directory, the file <log_dir>/task_<t>/<key> will contain the value.

        Args:
            dict_name_to_text (Dict[str, str]): a mapping from the name of the file to create to the text to write in it.
            in_task_folder (bool, optional): whether to log the files in the task folder (if not, log in the run folder). Defaults to True.
            is_update_step (bool, optional): whether we are in an update step (if so, replace task_t by task_t_update). Defaults to False.
        """
        list_log_dirs = []
        for run_name in self.list_run_names:
            log_dir = os.path.join(self.log_dir, run_name)
            if is_update_step:
                assert (
                    in_task_folder
                ), "is_update_step should be True if in_task_folder is True."
                log_dir = os.path.join(log_dir, f"task_{self.t}_update")
            elif in_task_folder:
                log_dir = os.path.join(log_dir, f"task_{self.t}")
            else:
                log_dir = log_dir
            list_log_dirs.append(log_dir)

        for log_dir in list_log_dirs:
            os.makedirs(log_dir, exist_ok=True)
            for name, text in dict_name_to_text.items():
                log_file = os.path.join(log_dir, name)
                with open(log_file, "w") as f:
                    f.write(text)
                f.close()
                print(f"[LOGGING] : Logged {log_file}")
