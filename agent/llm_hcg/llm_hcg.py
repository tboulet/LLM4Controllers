import json
import os
import re
import shutil
from typing import Dict, List, Optional

import numpy as np
from openai import OpenAI
from agent.base_agent import BaseAgent, Controller
from agent.llm_hcg.library_controller import ControllerLibrary
from agent.llm_hcg.demo_bank import DemoBank, Transition
from core.task import TaskRepresentation
from core.utils import get_error_info
from env.base_meta_env import BaseMetaEnv, Observation, ActionType, InfoDict
from abc import ABC, abstractmethod
import enum
import random
from typing import Any, Dict, Tuple, Union
from hydra.utils import instantiate
from llm import llm_name_to_LLMClass


class LLMBasedHierarchicalControllerGenerator(BaseAgent):

    def __init__(self, config: Dict):
        super().__init__(config)
        # Initialize LLM
        name_llm = config["llm"]["name"]
        config_llm = config["llm"]["config"]
        self.llm = llm_name_to_LLMClass[name_llm](config_llm)
        self.text_base_controller = open("agent/base_controller.py").read()
        self.text_answer_example = open("agent/llm_hcg/answer_example.txt").read()
        # Extract the configuration parameters
        self.model = config["model"]
        self.num_attempts_sc = config.get("num_attempts_sc", 5)
        # Initialize agent's variables
        self.t = 0  # Time step
        # Define the base namespace that can be used by the assistant
        self.namespace = {}
        exec(open("agent/llm_hcg/base_namespace.py").read(), self.namespace)
        self.sc_code_last: Optional[str] = (
            None  # The code of the controller generated by the assistant
        )
        # Initialize knowledge base
        self.library_controller = ControllerLibrary(
            config_agent=config,
        )
        self.demo_bank = DemoBank(
            config_agent=config,
        )
        # Initialize logging
        config_logs = self.config["config_logs"]
        self.log_dir = config_logs["log_dir"]
        self.list_run_names = []
        if config_logs["do_log_on_new"]:
            self.list_run_names.append(self.config["run_name"])
        if config_logs["do_log_on_last"]:
            self.list_run_names.append("_last")
        # Log the config
        self.log_texts(
            {"config.yaml": json.dumps(self.config, indent=4)}, in_task_folder=False
        )

    def give_textual_description(self, description: str):
        self.description_env = description

    def get_controller(self, task_description: TaskRepresentation) -> Controller:

        # Breakpoint-pause at each task if the debug mode is activated
        if self.config["config_debug"]["breakpoint_on_new_t"]:
            print(f"Task {self.t} : {task_description}. Press 'c' to continue.")
            breakpoint()

        # Extract demo bank examples to be given as in-context examples
        transitions = self.demo_bank.sample_transitions(
            task_description=task_description
        )
        examples_demobank = "\n\n".join(repr(transition) for transition in transitions)

        # Create the prompt for the assistant
        prompt = (
            # Purpose prompt
            "You will be asked to generate the code for a Controller and instanciate this controller for a given task in a RL-like environment. "
            "\n\n"
            # Environment prompt
            "[General description of the environment]\n"
            f"{self.description_env}\n"
            "\n\n"
            # Controller structure prompt
            "[Controller interface]\n"
            "A controller obeys the following interface:\n"
            "Note : you need to import the objects Controller, Observation, ActionType and InfoDict from the 'agent.base_agent' module.\n"
            "Also, you shall import any other python module you need (numpy as np, math, etc.).\n"
            "```python\n"
            f"{self.text_base_controller}```"
            "\n\n"
            # Knowledge base prompt
            f"{self.library_controller}"
            "\n\n"
            # Demo bank prompt
            "[Examples]\n"
            "Here are some examples of code used to solve similar tasks in the past. "
            "For each example, you are given the task description, the code used to solve it and the feedback given to the agent after the execution of the controller (performance of the agent, error detected, etc.). "
            "You can see these good/bad examples (depending on feedback) as a source of inspiration to solve the task. "
            "\n\n"
            f"{examples_demobank}"
            "\n\n"
            # Advice prompt
            "[Advices]\n"
            "You can write a new controller class and/or use the controllers that are already implemented in the knowledge base. "
            "If you define a controller from scratch, you can't define functions outside the controller class, you need to define them inside the class as methods. "
            "Your code should create a 'controller' variable that will be extracted for performing in the environment\n"
            # "\n" # (commented for now)
            # "You should try as much as possible to produce controllers that are short in terms of tokens of code. "
            # "This can be done in particular by re-using the functions and controllers that are already implemented in the knowledge base and won't cost a lot of tokens. "
            "\n"
            "Please reason step-by-step and think about the best way to solve the task before answering. "
            "\n\n"
            # Example of answer prompt (in-context learning)
            "[Example of answer]\n"
            "Your answer should be returned following that example:\n"
            f"{self.text_answer_example}"
            "\n\n"
            # Task prompt
            "[Task to solve]\n"
            f"Your task is : you will have to implement a controller (under the variable 'controller') to solve the following task : {task_description}."
        )
        self.log_texts({"prompt.txt": prompt})

        # Iterate until the controller is generated. If error, log it in the message and ask the assistant to try again.
        is_controller_instance_generated = False
        self.llm.reset()
        self.llm.add_prompt(prompt)
        for no_attempt in range(self.num_attempts_sc):
            # Ask the assistant
            answer = self.llm.generate()
            # Extract the code block from the answer
            sc_code = self.extract_SC_code(answer)
            if sc_code is None:
                # Retry if the code could not be extracted
                print(
                    f"[WARNING] : Could not extract the code from the answer. Asking the assistant to try again. (Attempt {no_attempt+1}/{self.num_attempts_sc})"
                )
                self.llm.add_answer(answer)
                self.llm.add_prompt(
                    "I'm sorry, extracting the code from your answer failed. Please try again and make sure the code obeys the following format:\n```python\n<your code here>\n```"
                )
                self.log_texts(
                    {f"assistant_answer_failed_{no_attempt}_extract_reason.txt": answer}
                )
                if self.config["config_debug"]["breakpoint_on_failed_sc_extraction"]:
                    print("sc_code extraction failed. Press 'c' to continue.")
                    breakpoint()
                continue
            # Extract the controller
            try:
                controller_instance = self.get_controller_instance(sc_code)
            except Exception as e:
                full_error_info = get_error_info(e)
                print(
                    f"[WARNING] : Could not execute the code from the answer. Asking the assistant to try again (Attempt {no_attempt+1}/{self.num_attempts_sc}). Full error info : {full_error_info}"
                )
                self.llm.add_answer(answer)
                self.llm.add_prompt(
                    f"I'm sorry, an error occured while executing your code. Please try again and make sure the code is correct. Full error info : {full_error_info}"
                )
                self.log_texts(
                    {
                        f"assistant_answer_failed_{no_attempt}_exec_reason.txt": answer,
                        f"error_info_exec_{no_attempt}.txt": full_error_info,
                    }
                )
                if self.config["config_debug"]["breakpoint_on_failed_sc_extraction"]:
                    breakpoint()
                continue
            # Save the code for update step and return the controller instance
            self.sc_code_last = sc_code
            # self.list_pc_imports_last = list_pc_imports
            is_controller_instance_generated = True
            break

        if is_controller_instance_generated:
            self.log_texts(
                {
                    "assistant_answer.txt": answer,
                    "controller.py": sc_code,
                }
            )
            return controller_instance

        else:
            raise ValueError(
                f"Could not generate a controller after {self.num_attempts_sc} attempts. Stopping the process."
            )

    def update(
        self,
        task_repr: TaskRepresentation,
        controller: Controller,
        feedback: Dict[str, Union[float, str]],
    ):
        # Add the transition to the demo bank
        self.demo_bank.add_transition(
            transition=Transition(
                task_repr=task_repr, code=self.sc_code_last, feedback=feedback
            )
        )
        # Update the knowledge base
        # TODO : implement the update of the knowledge base
        # Log the feedback
        self.log_texts(
            {
                "feedback.txt": json.dumps(feedback, indent=4),
            }
        )
        # Increment the time step
        self.t += 1

    # ================ Helper functions ================

    def extract_SC_code(self, answer: str) -> str:
        """Extracts the controller definition and instantiation code from an LLM response.
        The answer should contain one python code block with the controller code and instanciate a Controller variable named 'controller'.

        Args:
            answer (str): the answer from the LLM.

        Returns:
            str: the controller code.
        """
        sc_match = re.search(r"```python\n(.*?)\n```", answer, re.DOTALL)
        sc_code = sc_match.group(1).strip() if sc_match else None
        return sc_code

    

    def get_controller_instance(self, code: str) -> Controller:
        """
        Execute the code given by the LLM and return the controller instance.
        Because some imports may be fictional imports from the 'controller_library' module, we first extract those and execute them.

        Example :
        ```python
        from controller_library import Controller1, Controller2
        import numpy as np

        class MyController(Controller1):
            ... # code for the controller

        controller = MyController()
        ```

        Args:
            code (str): a string containing the code.
            The code should be structured as :
            - import statements from the (fictional) controller_library module (optional)
            - import statements from other standard modules (optional)
            - class definition (optional)
            - controller instantiation (mandatory)

        Returns:
            Controller: the controller instance.
        """
        code = """
from agent.base_agent import Controller, Observation, ActionType
from controller_library import MoveForwardController, azeazeaze

class MyController(MoveForwardController):
    def __init__(self):
        self.move_forward_controller = MoveForwardController()
    def act(self, observation: Observation) -> ActionType:
        return self.move_forward_controller.act(observation)
    def has_finished(self) -> bool:
        return self.move_forward_controller.has_finished()

controller = MyController()
"""
        # Extract imports from 'controller_library'
        lines = code.split("\n")
        lines_without_controller_imports: List[str] = []
        controller_classes_names: List[str] = []

        for line in lines:
            match = re.match(r"^\s*from\s+controller_library\s+import\s+(.+)$", line)
            if match:
                controller_classes_names.extend(
                    [cls.strip() for cls in match.group(1).split(",")]
                )
            else:
                lines_without_controller_imports.append(line)

        # Create a new execution context
        exec_globals = {}

        # Execute controller imports first
        for controller_name in controller_classes_names:
            assert controller_name in self.library_controller.controllers, f"Controller {controller_name} not found in the library."
            controller_code = self.library_controller.controllers[controller_name].code
            try:
                exec(controller_code, exec_globals)
            except Exception as e:
                raise ValueError(
                    f"An error occured while executing the code of the controller {controller_name} from the library. Maybe don't import this controller anymore. Full error info : {get_error_info(e)}"
                )
        # Execute the remaining code
        try:
            exec("\n".join(lines_without_controller_imports), exec_globals)
        except Exception as e:
            raise ValueError(
                f"An error occured while executing the code for instanciating a controller. Full error info : {get_error_info(e)}"
            )
            
        # Retrieve the controller instance specifically from 'controller' variable
        if "controller" in exec_globals and isinstance(
            exec_globals["controller"], Controller
        ):
            return exec_globals["controller"]
        else:
            raise ValueError("No object named 'controller' of the class Controller found in the provided code.")


    def log_texts(self, dict_name_to_text: Dict[str, str], in_task_folder: bool = True):
        """Log texts in a directory. For each (key, value) in the directory, the file <log_dir>/task_<t>/<key> will contain the value.

        Args:
            dict_name_to_text (Dict[str, str]): a mapping from the name of the file to create to the text to write in it.
        """
        list_log_dirs = [
            (
                f"{self.log_dir}/{run_name}/task_{self.t}"
                if in_task_folder
                else f"{self.log_dir}/{run_name}"
            )
            for run_name in self.list_run_names
        ]
        for log_dir in list_log_dirs:
            os.makedirs(log_dir, exist_ok=True)
            for name, text in dict_name_to_text.items():
                log_file = os.path.join(log_dir, name)
                with open(log_file, "w") as f:
                    f.write(text)
                f.close()
                print(f"[LOGGING] : Logged {log_file}")
